# 红黑树

上面介绍了二叉搜索树以及avl树，这里介绍另外一种近似平衡的二叉树-- 红黑树
它的每个节点都有5个属性: `color、key、left、right、p`

一棵红黑树通常拥有以下性质

1. 每个节点或是红色，或是黑色的 (rb)
2. 根节点是黑色的
3. 每个叶子节点也是黑色的
4. 如果一个节点是红色的，则它的两个子节点都是黑色的
5. 对于每个节点，从该节点到所有后代叶节点的简单路径上，均包含相同数目的黑色节点
   

![r_b_tree](../asserts/r_b_tree/rb.png)

## 它的插入删除以及访问的时间复杂度为 O(lgN)
定义，**bh(x)** (black height) 为黑高，即节点`x`到期叶子节点的黑色节点的个数
### 证明:

一个n个内部节点的红黑树，它的高度最多为 2lg(n+1) 
首先证明:
一个节点的x的最好含有`2^(bh(x))-1`个节点


由性质5，可以看出:

对于一个任意节点`x`，它的左右节点的黑高为`bh(x)`或者`bh(x)-1`.即它的最少黑高为`bh(x)-1`，则 以x为根的子树，至少含有

```2^(bh(x)-1-1+2^(bh(x)-1)-1+1 = 2^bh(x)-1```

个节点数，

由性质4，可以看出
对于高度为h的红黑树，它的黑高至少为h/2,所以 

```n>=2^(h/2)-1 ```

解之可🉐, ```h<= 2lg(n+1)```

得证

##调整节点

与avl树，类似，红黑树的插入或者删除，可能破坏其平衡(性质)。因此需要进行旋转调整。

### 平衡的破坏

我们设定每次插入的元素都是红色节点(这样子可以避免最坏情况的发生)，这样子不会破坏性质1、3、5.

对于性质2的破坏，我们很容易进行识别出来。对于性质4的破坏，我们要进行简单分析一下。

对于更新破坏红黑树特性的问题，有一些调整的方法:
- BST operation
- Color changes
- Restructure the tree via rotation (recolor、lint)



### 左旋 and 右旋
![](https://raw.githubusercontent.com/hsjfans/git_resource/master/20190506121552.png)








## Related

1. [skip_list](./skip_list.md)
2. [avl_tree](./avl_tree.md)
3. [Treap](./treap.md)
